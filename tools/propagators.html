<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Propagators &mdash; CDTools 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=938c9ccc"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Measurements" href="measurements.html" />
    <link rel="prev" title="Interactions" href="interactions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            CDTools
          </a>
              <div class="version">
                0.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction to CDTools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../general.html">General Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Models</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image_processing.html">Image Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="initializers.html">Initializers</a></li>
<li class="toctree-l2"><a class="reference internal" href="interactions.html">Interactions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Propagators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.far_field"><code class="docutils literal notranslate"><span class="pre">far_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.near_field"><code class="docutils literal notranslate"><span class="pre">near_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.generate_angular_spectrum_propagator"><code class="docutils literal notranslate"><span class="pre">generate_angular_spectrum_propagator()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.inverse_far_field"><code class="docutils literal notranslate"><span class="pre">inverse_far_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.inverse_near_field"><code class="docutils literal notranslate"><span class="pre">inverse_near_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.generate_high_NA_k_intensity_map"><code class="docutils literal notranslate"><span class="pre">generate_high_NA_k_intensity_map()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.high_NA_far_field"><code class="docutils literal notranslate"><span class="pre">high_NA_far_field()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdtools.tools.propagators.generate_generalized_angular_spectrum_propagator"><code class="docutils literal notranslate"><span class="pre">generate_generalized_angular_spectrum_propagator()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="measurements.html">Measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="losses.html">Losses</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotting.html">Plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="analysis.html">Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../indices_tables.html">Indices and tables</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CDTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tools</a></li>
      <li class="breadcrumb-item active">Propagators</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tools/propagators.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-cdtools.tools.propagators">
<span id="propagators"></span><h1>Propagators<a class="headerlink" href="#module-cdtools.tools.propagators" title="Link to this heading"></a></h1>
<p>This module contains various propagators for light fields</p>
<p>All the functions here are designed for use in an automatic differentiation
ptychography model. Each function implements a different propagator.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.far_field">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">far_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavefront</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.far_field" title="Link to this definition"></a></dt>
<dd><p>Implements a far-field propagator in torch</p>
<p>This accepts a torch tensor, where the last dimension
represents the real and imaginary components of the wavefield,
and returns the far-field propagated version of it assuming it matches the
detector dimensions. It assumes that the
propagation is purely far-field, without checking that the geometry
is consistent with that assumption.</p>
<p>It also assumes that the real space wavefront is stored in an array
[i,j] where i corresponds to the y-axis and j corresponds to the
x-axis, with the origin following the CS standard of being in the
upper right. The zero frequency component of the propagated wavefield is
shifted to the center of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>wavefront</strong> (<em>torch.Tensor</em>) – The JxNxMx2 stack of complex wavefronts to be propagated</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagated</strong> – The JxNxMx2 propagated wavefield</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.near_field">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">near_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavefront</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angular_spectrum_propagator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.near_field" title="Link to this definition"></a></dt>
<dd><p>Propagates a wavefront via the angular spectrum method</p>
<p>This function accepts an 3D torch tensor, where the last dimension
represents the real and imaginary components of the wavefield, and
returns the near-field propagated version of it. It does this
using the supplied angular spectrum propagator, which is a premade
phase mask representing the Fourier transform of the kernel for
light propagation in the desired geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavefront</strong> (<em>torch.Tensor</em>) – The (Leading Dims)xNxM stack of complex wavefronts to be propagated</p></li>
<li><p><strong>angular_spectrum_propagator</strong> (<em>torch.Tensor</em>) – The NxM phase mask to be applied during propagation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagated</strong> – The propagated wavefront</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.generate_angular_spectrum_propagator">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">generate_angular_spectrum_propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandlimit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.generate_angular_spectrum_propagator" title="Link to this definition"></a></dt>
<dd><p>Generates an angular-spectrum based near-field propagator from experimental quantities</p>
<p>This function generates an angular-spectrum based near field
propagator that will work on torch Tensors. The function is structured
this way - to generate the propagator first - because the
generation of the propagation mask is a bit expensive and if this
propagator is used in a reconstruction program, then it will be best
to calculate this mask once and reuse it.</p>
<p>Formally, this propagator is the the fourier transform of the convolution
kernel for light propagation in free space</p>
<p>If the optional bandlimit parameter is set, the propagator will be set
to zero beyond an explicit bandlimiting frequency. This is helpful if the
propagator will be used in a repeated multiply/propagate framework such
as a multislice algorithm, where it helps to prevent aliasing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>array</em>) – The shape of the arrays to be propagated</p></li>
<li><p><strong>spacing</strong> (<em>array</em>) – The pixel size in each dimension of the arrays to be propagated</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – The wavelength of light to simulate propagation of</p></li>
<li><p><strong>z</strong> (<em>float</em>) – The distance to simulate propagation over</p></li>
<li><p><strong>bandlimit</strong> (<em>float</em>) – Optional, a fraction of the full detector radius beyond which to set the propagator to zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagator</strong> – A phase mask which accounts for the phase change that each plane wave will undergo.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.inverse_far_field">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">inverse_far_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavefront</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.inverse_far_field" title="Link to this definition"></a></dt>
<dd><p>Implements the inverse of the far-field propagator in torch</p>
<p>This accepts a torch tensor, where the last dimension
represents the real and imaginary components of the propagated wavefield,
and returns the un-propagated array.</p>
<p>It assumes that the real space wavefront is stored in an array
[i,j] where i corresponds to the y-axis and j corresponds to the
x-axis, with the origin following the CS standard of being in the
upper right. The zero frequency component of the propagated wavefield is
assumed to be the center of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>wavefront</strong> (<em>torch.Tensor</em>) – The JxNxMx2 stack of complex wavefronts propagated to the far-field</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagated</strong> – The JxNxMx2 exit wavefield</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.inverse_near_field">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">inverse_near_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavefront</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angular_spectrum_propagator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.inverse_near_field" title="Link to this definition"></a></dt>
<dd><p>Inverse propagates a wavefront via the angular spectrum method</p>
<p>This function accepts an 3D torch tensor, where the last dimension
represents the real and imaginary components of the wavefield, and
returns the near-field propagated version of it. It does this
using the supplied angular spectrum propagator, which is a premade
phase mask.</p>
<p>It propagates the wave using the complex conjugate of the supplied
phase mask. This corresponds to propagation backward across the original
propagation region - however, the treatment of evanescent waves is such
that evanescent waves will decay both during the forward propagation and
inverse propagation. This is done for reasons of numerical stability,
as the choice to magnify evanescent waves during the inverse propagation
process will quickly lead to magnification of any small amount of noise at
frequencies larger than k_0, and in most typical situations will even
lead to overflow of the floating point range. If evanescent waves need
to be treated appropriately for any reason, it is recommended to use the
“magnify_evanescent” option in the appropriate helper function used to
generate the propagation phase mask. In this case, evanescent waves will
be magnified both when used with the forward and inverse near field
functions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavefront</strong> (<em>torch.Tensor</em>) – The JxNxMx2 stack of complex wavefronts to be propagated</p></li>
<li><p><strong>angular_spectrum_propagator</strong> (<em>torch.Tensor</em>) – The NxM phase mask to be applied during propagation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagated</strong> – The inverse propagated wavefront</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.generate_high_NA_k_intensity_map">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">generate_high_NA_k_intensity_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.generate_high_NA_k_intensity_map" title="Link to this definition"></a></dt>
<dd><p>Generates k-space and intensity maps to allow for high-NA far-field propagation of light</p>
<p>At high numerical apertures or for very tilted samples, the simple
linear map between location on the detector and location in k-space
starts to break down. In addition, at angles above roughly 15 degrees,
a correction is needed to account for the decreasing solid angle
intersected by each pixel on the detector.</p>
<p>This function generates a map which can be used to apply both corrections
via the high_NA_far_field propagator. The k-map which is output is
defined as a map between pixel location on the detector and locations
in the output of the standard, low-NA far-field propagated wavefield.
The output coordinate system is defined to run from -1 to 1 in both
directions - this allows for compatibility with pytorch’s grid_sample
function. Some detector pixels may be mapped to values outside the
rangel [-1,1], depending on the respective sample and detector geometries.
This is most likely to be the case if the major correction is due to a
tilted sample.</p>
<p>The intensity map is simply an object, the shape of the detector, which
encodes intensity corrections between 0 and 1 per pixel.</p>
<p>If the optional “lens” parameter is set to True, the intensity map will
be set to a uniform map, and the distortion of Fourier space due to the
flat nature of the detector (that is, the portion of the distortion
that exists even if the sample is not tilted) will be disabled. This is
to account for the fact that a good, infinity-conjugate imaging lens
will do it’s best to correct for these abberations in the lens. Of course,
the lens will not be perfect, but in such a case it is a better
approximation to assume that the lens is perfect than to assume that it
is not there at all.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_basis</strong> (<em>array</em>) – The 3x2 sample basis, in real space</p></li>
<li><p><strong>det_basis</strong> (<em>array</em>) – The 3x2 detector basis, in real space</p></li>
<li><p><strong>det_shape</strong> (<em>array</em>) – The length-2 shape of the detector array, (N,M)</p></li>
<li><p><strong>distance</strong> (<em>float</em>) – The sample-to-detector distance</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – The wavelength of light being propagated</p></li>
<li><p><strong>lens</strong> (<em>bool</em>) – Whether the diffraction pattern is formed by a lens or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>k_map</strong> (<em>torch.Tensor</em>) – An NxMx2 tensor mapping detector pixels to locations in the low-NA propagated wavefield</p></li>
<li><p><strong>intensity_map</strong> (<em>torch.Tensor</em>) – An NxM tensor encoding the high-NA intensity correction</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.high_NA_far_field">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">high_NA_far_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavefront</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.high_NA_far_field" title="Link to this definition"></a></dt>
<dd><p>Performs a far-field propagation step including a correction for high-NA scenarios</p>
<p>Two major corrections need to be performed when propagating light fields
into the far field at high numerical aperture or when the sample is
tilted as compared to the detector. The first correction is a deviation
from the linear relationship between detector position and spatial
frequency in the near field. This is accounted for with the k_map
argument, as generated by the generate_high_NA_k_intensity_map
function.</p>
<p>The second correction is the change in the solid angle which each pixel
subtends at high NA. This is accounted for with an optional intensity
map. This is kept optional because some detectors - specifically, those
for penetrating radiation - may either not need a correction or need
a different correction due to the volumetric nature of the pixels.</p>
<p>If the k-map maps any pixels on the detector to pixels outside of the
k-space range of the wavefront, these will be set to zero. This is in
keeping with the typical assumption that the sample is band-limited to
the Nyquist frequency for the array on which it is sampled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavefront</strong> (<em>torch.Tensor</em>) – The JxNxMx2 stack of complex wavefronts propagated to the far-field</p></li>
<li><p><strong>k_map</strong> (<em>torch.Tensor</em>) – The NxMx2 map accounting for high NA distortion, as generated by generate_high_NA_k_intensity_map</p></li>
<li><p><strong>intensity_map</strong> (<em>torch.Tensor</em>) – The optional NxM tensor accounting for the intensity variation across the detector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagated</strong> – The JxNxMx2 exit wavefield</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cdtools.tools.propagators.generate_generalized_angular_spectrum_propagator">
<span class="sig-prename descclassname"><span class="pre">cdtools.tools.propagators.</span></span><span class="sig-name descname"><span class="pre">generate_generalized_angular_spectrum_propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_vector</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propagation_vector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propagate_along_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cdtools.tools.propagators.generate_generalized_angular_spectrum_propagator" title="Link to this definition"></a></dt>
<dd><p>Generates an angular-spectrum based near-field propagator from experimental quantities</p>
<p>This function generates an angular-spectrum based near field
propagator that will work on torch Tensors. The function is structured
this way - to generate the propagator first - because the
generation of the propagation mask is a bit expensive and if this
propagator is used in a reconstruction program, it will be best
to calculate this mask once and then reuse it it.</p>
<p>Formally, this propagator is the fourier transform of the convolution
kernel for light propagation in free space. It will map a light field
at an input plane, with the size and shape defined by the shape and basis
inputs, and map it to a plane of the same size and shape offset by the
offset vector. It is designed to work on any wavefield defined on an
array of parallelograms.</p>
<p>In addition, if the propagation_vector is set, there is an assumed
phase ramp  applied to the wavefield before propagation, defined such
that a feature with uniform phase will propagate along the direction of
the propagation vector. This will also remove the phase variation along
the propagation direction, because it makes the most physical sense to
regard this choice as removing the dominant phase variation in 3D, allowing
for the generation of a smoothly varying wavefield over 3D volumes.
This decision provides the best numerical stability and allows for the
simple setup of light fields copropagating with the coordinate system.</p>
<p>If the propagate_along_offset option is set to True, then the propagation
vector will be set equal to the offset vector. This overrides the
propagation_vector option</p>
<p>Note that, unlike in the case of the simple angular spectrum propagator,
the direction of “forward propagation” is defined by the propagation
vector, or (if the propagation vector is not defined), the offset
vector. Therefore, in the simple case of a perpendicular offset,
there will be no difference between using an offset vector or the
negative of the  offset vector. This is because, for the light
propagation problem to be well posed, the assumption must be made that
light only passes through the plane of the known wavefield in one
direction. We always assume that light passes through the initial plane
travelling in the direction of the final plane.</p>
<p>Practically, if one wants to simulate inverse propagation, there are
two possible approaches. First, one can use the inverse_near_field
function, which simulates the inverse propagation problem and therefore
will naturally simulate propagation in the opposite direction. Second,
one can explicitly include a propagation_vector argument, in the direction
opposite to the offset vector. Note for both cases that this function
will only return propagators which suppress evanescent waves. Thus,
propagating forward and then backward by either of these two methods
will lead to a supression of evanescant waves. If you need a propagator
that will cause evanescent waves to undergo exponential growth, good
for you, but this function will not provide it for you.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>array</em>) – The shape of the arrays to be propagated</p></li>
<li><p><strong>basis</strong> (<em>array</em>) – The (2x3) set of basis vectors describing the array to be propagated</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – The wavelength of light to simulate propagation of</p></li>
<li><p><strong>offset_vector</strong> (<em>array</em>) – The displacement to propagate the wavefield along.</p></li>
<li><p><strong>propagation_vector</strong> (<em>array</em>) – The vector along which to include an implied phase ramp to propagate uniform phase features along, if set</p></li>
<li><p><strong>propagate_along_offset</strong> (<em>bool</em>) – Overrides propagation_vector, sets the propagation vector to equal the offset vector if set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>propagator</strong> – A phase mask which accounts for the phase change that each plane wave will undergo.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="interactions.html" class="btn btn-neutral float-left" title="Interactions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="measurements.html" class="btn btn-neutral float-right" title="Measurements" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2024, Abraham Levitan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>